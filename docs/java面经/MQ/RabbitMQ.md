## RabbitMQ 提供了多种消息传递模式

- 工作队列模式：多个消费者共享一个队列，消息被均匀分配，实现负载均衡，适用于任务分发。
- 发布/订阅模式：消息广播到所有绑定队列，实现“一对多”消息分发，适用于消息需要被多个消费者同时接收的场景。
- 路由模式：订阅模式的升级版，在订阅模式能实现的场景下，根据路由键（Routing Key）将消息定向发送到指定队列，适用于需要精确匹配路由键的场景（如果所有的路由键都相同，则实现效果与订阅模式相同）。
- 通配符模式（Topics）：路由模式的升级版，通过使用通配符匹配一个或者多个词来匹配路由键，实现更灵活的路由。（每个词中间以.分隔，*匹配一个词，#匹配多个词，比如inform.#可以匹配inform.sms、inform.sms.email，inform.*只能匹配inform.sms、inform.email）
- RPC模式：实现远程过程调用，客户端发送请求并等待服务端响应。
- Headers模式：根据消息的头部属性进行路由，不依赖路由键，但性能较低，使用较少。

## 与 springboot 的整合

- RabbitTemplate：会维护一个连接池，以提高消息发送的效率。如果连接意外断开，它会尝试重新连接。当程序关闭，它会关闭所有打开的连接和通道，释放相关资源。
- @RabbitListener：使用该注解，可以实现监听队列，并自动处理消息。

## 死信队列

- 死信队列本身是一个普通队列，只是被设计为处理无法被正常处理的消息。所以称之为死信队列。
- 在RabbitMQ中，消息要进死信队列必须满足 三选一：消息被拒绝、消息超时过期（TTL到点）、队列长度超限。

## 延迟消息的实现

- RabbitMQ本身不支持延迟消息，要么借助第三方工具实现，要么借助死信队列来实现。
- 如果不想使用第三方工具，可以通过死信队列来实现延迟消息。
- 借助死信队列实现的原理：创建普通队列，不做消费者，设置消息过期时间，过期后消息进入死信队列，被死信消费者处理。
