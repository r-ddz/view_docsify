## 关注点

> 如何将类或对象按某种布局组成更大的结构。

## 外观模式（门面模式）（Facade）

- 对外解耦。
- 它为复杂的子系统提供一个统一的高层接口，隐藏其内部复杂性，使得子系统更易于使用。

## 装饰器模式（Decorator）

- 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
- 例子1：Java I/O 流体系（如 BufferedReader(Reader in)、ZipInputStream(InputStream in)）。
- 例子2：excel相关类，如XSSFWorkbook、HSSFWorkbook。

## 组合模式 (Composite)

- 将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。
- 树形结构就是一种组合模式。递归是一种遍历树形结构的常用方法。

## 享元模式 (Flyweight)

- 目的：运用共享技术有效地支持大量细粒度对象的复用。
- 典型应用：Java 中的字符串常量池、Integer.valueOf(int) 方法（缓存了小整数对象）。

## 代理模式 (Proxy)

- 静态代理：手写一个代理对象，嵌套调用被代理类的逻辑，可让代理类和被代理类实现同接口以增加可扩展性。
- 动态代理：利用反射机制创建代理对象和调用逻辑，Spring的AOP就是基于动态代理的。

## 适配器模式 (Adapter)

- 目的：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- 典型应用：Arrays.asList()、InputStreamReader(InputStream)（连接 InputStream 和 Reader）。
- 之前的项目里，EDI其实就是一种适配器模式的思路。

## 桥接模式 (Bridge)

- 目的：将抽象部分与其实现部分分离，使它们都可以独立地变化。
- 典型应用：JDBC 驱动程序，其中“连接”是抽象，“数据库驱动”是实现，二者可以独立演化。
- 思考：之前项目里对各平台的api接口，因为平台数量和接口数量，产生了 n × n 的接口，如果能用桥接模式将平台作为抽象部分分离出来，可以精简成 n + n 个接口，防止类爆炸。这样的实现即是桥接模式，但为了考虑代码的可读性，一般不这么写（现在桥接模式在实际应用中使用较少）。
