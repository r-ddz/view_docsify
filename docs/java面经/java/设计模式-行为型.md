## 关注点

> 对象之间的职责分配和通信。

## 策略模式（Strategy）

- 定义一系列算法，将每个算法都封装起来，并使他们可以相互替换，我们经常写的排序很多时候用的就是策略模式，直接传递一个排序算法，然后调用这个算法进行排序，现在结合lambda表达式，可以很方便的实现策略模式。

## 中介者模式（调停者模式）（Mediator）

- 对内解耦。
- 旨在减少对象之间的直接依赖，通过引入一个中介者对象来协调多个对象之间的交互。
- 消息中间件（MQ）就是一种常见的中介者模式。

## 责任链模式（Chain of Responsibility）

- 目的：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
- 典型应用：Java Servlet 中的过滤器（Filter）链、异常处理机制（try-catch 块）。
- 之前项目里的审单节点的用法，就是一种责任链模式。如果能设计的更完善一点，也可以多个审单节点作为一个大节点存在责任链内部。

## 观察者模式 (Observer)

- 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
- 典型应用：Java 自带的 java.util.Observer 和 Observable（已过时），以及更现代的 PropertyChangeListener。RxJava、EventBus 等事件总线框架是其更强大的实现。
- 之前项目里的出入库单完结改变业务单据的状态，还有单据明细改变汇总单头的数据，就是一种简单粗暴的观察者模式。但仍需完善的设计，才能满足更复杂的扩展需求。

## 迭代器模式 (Iterator)

- 提供一种方法遍历一个聚合对象中各个元素，而又无须暴露该对象的内部表示。 典型应用：Java 集合框架中的 Iterator（如 List.iterator()）。
- 思考：借助java8新特性的Lambda表达式和函数式接口，可以将迭代器模式再次封装，实现类似`forEach`的效果。

## 访问者模式 (Visitor)

- 目的：主要将数据结构与数据操作分离。表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
- 典型应用：对抽象语法树（AST）进行操作、编译器的语义分析。
- 实际应用中比较少，之前项目里的日志模块，其实可以借助访问者模式实现，比如数据库存存储完整json日志，然后分别为多个访问者（开发人员、业务人员）实现不同的展示效果。

## 命令模式 (Command)

- 目的：将一个请求封装为一个对象，从而使您可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
- 典型应用：GUI 中的按钮点击事件（ActionListener）、事务管理、宏命令。
- 思考：一些分布式框架的回滚实现思路就是借助命令模式，通过记录数据改动前后，然后在回滚时，将数据恢复到原始状态。

## 备忘录模式 (Memento)

- 目的：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。
- 典型应用：游戏的存档功能、文本编辑器的撤销（Undo）功能。
- 思考：该模式使用的时候大多借助序列化进行存档，例如分布式框架的回滚，借助备忘录模式，可以记录数据改动前后，在回滚时，将数据恢复到原始状态。

## 模板方法模式（钩子函数、回调函数） (Template Method)

- 目的：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
- 典型应用：Java.io.InputStream 类的 read() 方法，它调用了抽象的 read(byte b[], int off, int len) 方法。Servlet 中的 HttpServlet 类（doGet, doPost 方法）。

## 状态模式 (State)

- 目的：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
- 典型应用：工作流或游戏中的角色状态切换（如订单状态：已下单、已支付、已发货）。

## 解释器模式 (Interpreter)

- 目的：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
- 典型应用：SQL 解析、正则表达式引擎。（相对不常用）