## 单例模式

- 可以将构造函数私有化，并添加一个静态的成员变量，用于保存单例对象。这样，在第一次调用`getInstance()`时，会创建一个对象，并保存在静态变量中。之后，每次调用`getInstance()`时，都会返回保存的静态变量中的对象。这样，就实现了单例模式。
- 现在大多数将bean交给spring管理，所以需要自己写单例的场景变少了。
- 利用枚举，实现单例，jvm底层枚举类本身是单例的。

## 策略模式

- 定义一系列算法，将每个算法都封装起来，并使他们可以相互替换，我们经常写的排序很多时候用的就是策略模式，直接传递一个排序算法，然后调用这个算法进行排序，现在结合lambda表达式，可以很方便的实现策略模式。

## 简单工厂

- 创建一个工厂类，根据传入的参数，返回一个对象。但凡能够创建对象，都可以认为这个类就是一个工厂类。

## 抽象工厂

- 抽象工厂模式，就是有一个抽象工厂类，这个抽象工厂类里面定义了一个创建对象的方法，这个方法返回一个抽象产品类。然后通过抽象工厂类的子工厂类来创建对象。

## 外观模式（门面模式）（Facade）

- 对外解耦。
- 它为复杂的子系统提供一个统一的高层接口，隐藏其内部复杂性，使得子系统更易于使用。

## 中介者模式（调停者模式）（Mediator）

- 对内解耦。
- 旨在减少对象之间的直接依赖，通过引入一个中介者对象来协调多个对象之间的交互。
- 消息中间件（MQ）就是一种常见的中介者模式。

## 装饰器模式（Decorator）

- 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
- 例子1：Java I/O 流体系（如 BufferedReader(Reader in)、ZipInputStream(InputStream in)）。
- 例子2：excel相关类，如XSSFWorkbook、HSSFWorkbook。

## 责任链模式（Chain of Responsibility）

- 目的：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
- 典型应用：Java Servlet 中的过滤器（Filter）链、异常处理机制（try-catch 块）。
- 之前项目里的审单节点的用法，就是一种责任链模式。如果能设计的更完善一点，也可以多个审单节点作为一个大节点存在责任链内部。

## 观察者模式 (Observer)

- 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
- 典型应用：Java 自带的 java.util.Observer 和 Observable（已过时），以及更现代的 PropertyChangeListener。RxJava、EventBus 等事件总线框架是其更强大的实现。
- 之前项目里的出入库单完结改变业务单据的状态，还有单据明细改变汇总单头的数据，就是一种简单粗暴的观察者模式。但仍需完善的设计，才能满足更复杂的扩展需求。

## 组合模式 (Composite)

- 将对象组合成树形结构以表示“部分-整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。
- 树形结构就是一种组合模式。递归是一种遍历树形结构的常用方法。

## 享元模式 (Flyweight)

- 目的：运用共享技术有效地支持大量细粒度对象的复用。
- 典型应用：Java 中的字符串常量池、Integer.valueOf(int) 方法（缓存了小整数对象）。

## 代理模式 (Proxy)

- 静态代理：手写一个代理对象，嵌套调用被代理类的逻辑，可让代理类和被代理类实现同接口以增加可扩展性。
- 动态代理：利用反射机制创建代理对象和调用逻辑，Spring的AOP就是基于动态代理的。



