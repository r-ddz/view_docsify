## 单例模式

- 可以将构造函数私有化，并添加一个静态的成员变量，用于保存单例对象。这样，在第一次调用`getInstance()`时，会创建一个对象，并保存在静态变量中。之后，每次调用`getInstance()`时，都会返回保存的静态变量中的对象。这样，就实现了单例模式。
- 现在大多数将bean交给spring管理，所以需要自己写单例的场景变少了。
- 利用枚举，实现单例，jvm底层枚举类本身是单例的。

## 策略模式

- 定义一系列算法，将每个算法都封装起来，并使他们可以相互替换，我们经常写的排序很多时候用的就是策略模式，直接传递一个排序算法，然后调用这个算法进行排序，现在结合lambda表达式，可以很方便的实现策略模式。

## 简单工厂

- 创建一个工厂类，根据传入的参数，返回一个对象。但凡能够创建对象，都可以认为这个类就是一个工厂类。

## 抽象工厂

- 抽象工厂模式，就是有一个抽象工厂类，这个抽象工厂类里面定义了一个创建对象的方法，这个方法返回一个抽象产品类。然后通过抽象工厂类的子工厂类来创建对象。

## 外观模式（门面模式）（Facade）

- 对外解耦。
- 它为复杂的子系统提供一个统一的高层接口，隐藏其内部复杂性，使得子系统更易于使用。

## 中介者模式（调停者模式）（Mediator）

- 对内解耦。
- 旨在减少对象之间的直接依赖，通过引入一个中介者对象来协调多个对象之间的交互。
- 消息中间件（MQ）就是一种常见的中介者模式。

## 装饰器模式（Decorator）

- 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
- 例子1：Java I/O 流体系（如 BufferedReader(Reader in)、ZipInputStream(InputStream in)）。
- 例子2：excel相关类，如XSSFWorkbook、HSSFWorkbook。