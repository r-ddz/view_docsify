## 选择合适的垃圾回收器（G1、CMS）

- 降低STW时间，减少垃圾回收导致的停顿时间。
- 减少GC频率，减少频繁的垃圾回收。

## 优化内存分配

- 合理设置堆内存大小（-Xms、-Xmx）和新生代、老年代的比例（-XX:NewRatio、-X:SurvivorRatio），减少频繁的垃圾回收。
- 调整对象晋升老年代的年龄阈值（-XX:MaxTenuringThreshold）和大对象直接进入老年代的标准（-XX:PretenureSizeThreshold），降低Full GC的触发频率。

## 监控与分析
- 使用监控工具：通过JConsole、VisualVM、Arthas等工具，实时监控JVM的内存、GC、线程状态，分析性能瓶颈。
- 分析GC日志：启用GC日志（-Xlog:gc*），使用GCEasy等工具分析日志，了解GC行为和内存使用情况。
- Arthas（阿尔萨斯）是一个强大的工具，结合idea的Arthas插件，可以快速生成命令，改改即用。

## 调整线程参数

- 优化线程池配置，提高并发性能。
- 线程太多，造成资源浪费，并且线程数过高，可能会导致CPU频繁切换被占满，从而影响性能。
- 线程数过少，可能会导致任务无法并发执行，从而影响性能。
- 排队时间太少，错误率高。
- 排队时间太长，影响平均耗时，也造成阻塞。

## 其他总结

- 对于系统的优化，不仅仅是在运行环境进行优化，还需要在代码本身做优化，如果代码本身存在性能问题，那么在其他方面再怎么优化也不可能达到效果最优的。
- 实战经验，最好的方式是针对实际业务需求，对固定的QPS进行系统调优（例如-Xms512m -Xmx2048m 满足核心业务500的QPS，-Xms4g -Xmx8g 满足核心业务1000的QPS），然后再根据实际的生产环境，进行水平扩展。